class VoterController < ApplicationController
  def index
    require 'csv'

    #puts Dir.entries("/Users/malsadi/external/")
    @table = CSV.parse(File.read("/public/files/voters.csv"), headers: true)
    #puts "trying to generate a file to volume"

    #out_file = File.new("public/files/out.txt", "w")
    #out_file.puts("This file was generated by Ruby docker image")
    #out_file.close
  end

  def elections
    require 'json'
    json = File.read('/public/files/elections.json')
    @parsed_json = JSON.parse(json)
  end

  def login
    require 'csv'
    require 'json'
    @voter = params[:voter]
    @election_name = params[:election]

    # Date and Time Check against current Date and Time
    jsonObj = File.read('/public/files/elections.json')
    elections = JSON.parse(jsonObj)
    election = elections["elections"].select { |obj| obj['name'].to_s == @election_name.to_s}.first
    startTime = Time.parse(election["start_time"])
    endTime   = Time.parse(election["end_time"])
    electionDate = Date.strptime(election["sdate"], '%d-%m-%y')

    @dateCompare = electionDate == Date.today

    @timeCompare = startTime< Time.now || Time.now<endTime

    if !@voter.nil?
      if verify_recaptcha
        @code = @voter[:code]
        table = CSV.parse(File.read('/public/files/ers-associated-voters.csv'), headers: true)
        voterID = get_voter_id_by_code(@code)
        if ! voterID.nil?
          voter_obj = table.select { |row| row['id'].to_i == voterID.to_i}.first
          @beta = voter_obj['beta']
        end
        if !voter_obj.nil?
          session[:voter]      = @beta
          session[:expires_at] = Time.current + 1.minutes
          session[:election]   = @election_name
          puts "Voter login successfull"
    
          if votedBefore(@beta).nil?
            redirect_to :controller => 'voter', :action => 'ballot', params: request.query_parameters
          else
            redirect_to :controller => 'voter', :action => 'Profile', params: request.query_parameters
          end
        else
          flash[:danger] = 'Invalid login code, please check your email and try again.'
          redirect_to '/voter/login/?election='+@election_name
        end
      end

    end
  end
  
  def ballot
    require 'json'
    json = File.read('/public/files/elections.json')
    @parsed_json = JSON.parse(json)
  end

  def Profile
  end

  def vote_summary
    require 'json'
    @checkes = params[:candidate]
    @election_name = params[:election]
    @voter = params[:voter]
    json = File.read('/public/files/elections.json')
    @parsed_json = JSON.parse(json)
  end

  def castVote
    require 'csv'

    betaVal = session[:voter] #params[:voter]
    if votedBefore(betaVal).nil?
      plainVote =  params[:vote]
      voters = CSV.parse(File.read('/public/files/ers-associated-voters.csv'), headers: true)
      voter = voters.select { |row| row['beta'].to_i == betaVal.to_i}.first

      CSV.open( '/public/files/ers-plaintext-voters.csv', 'a+' ,:headers => true, quote_char: " ") do |writer|
        writer.puts(["\"#{betaVal.to_s}\"", voter["id"].to_i, "\"#{plainVote.to_s}\"", "\"#{voter["encryptedTrackerNumberInGroup"].to_s}\"", "\"#{voter["publicKeySignature"].to_s}\"", "\"#{voter["publicKeyTrapdoor"].to_s}\""])
      end

      flash[:success] = 'Your Vote has been successfully recorded. Thank You for participating.'
      session.clear
      redirect_to '/voter/login?election=DemoElection'

    else
      redirect_to :controller => 'voter', :action => 'Profile', params: request.query_parameters
    end
  end

  def get_voter_id_by_code(code)
    require 'csv'
    table = CSV.parse(File.read("/public/files/voters.csv"), headers: true)
    voter_obj = table.select { |row| row['code'].to_i == code.to_i}.first
    if !voter_obj.nil?
      return voter_obj['id']
    else
      return nil
    end
  end

  def votedBefore(val)
    registeredVotes = CSV.parse(File.read('/public/files/ers-plaintext-voters.csv'), headers: true)
    voter = registeredVotes.select { |row| row['beta'].to_i == val.to_i}.first
    return voter
  end

  def results

    require 'csv'
    if  !File.exist?('/public/files/public-mixed-voters.csv')
      flash[:danger] = 'The election result has not been published yet. Please try later.'
      redirect_to '/voter/Profile/'
    end
    plainVotes = CSV.parse(File.read('/public/files/public-mixed-voters.csv'), headers: true)
    @hash = Hash.new(0)
    plainVotes.each { |pVote|
      if !@hash.has_key?(pVote["plainTextVote"])
        freq = score(plainVotes, pVote["plainTextVote"])
        @hash.store(pVote["plainTextVote"], freq)
      end
    }
  end

  def score( array, vote )
    count = 0
    for obj in array
      if obj["plainTextVote"] == vote
        count += 1
      end
    end
    return count

    #hash = Hash.new(0)
    #array.each{|key| hash[key] += 1}
    #hash
  end

  def verify
    @election = params[:election]
    @beta     = params[:beta].to_i
    alpha    = params[:alpha]

    encryptedVoters = CSV.parse(File.read('/public/files/public-encrypted-voters.csv'), headers: true)
    voter= encryptedVoters.select { |row| row['beta'].to_i == @beta}.first

    publicTrapdoorKey = voter["publicKeyTrapdoor"].to_i

    keys = CSV.parse(File.read('/public/files/voters-keys.csv'), headers: true)
    key =  keys.select { |row| row['publicKeyTrapdoor'].to_i == publicTrapdoorKey}.first

    private_key = key["privateKeyTrapdoor"].to_i



    elections = CSV.parse(File.read('/public/files/public-election-params.csv'), headers: true)
    election = elections.select {|row| row["name"].to_s == @election.to_s}.first
    p = election["p"].to_i


    require 'openssl'
    newAlpha = OpenSSL::BN.new(alpha, 10)
    newBeta  = OpenSSL::BN.new(@beta,10)
    newSK    = OpenSSL::BN.new(private_key, 10)
    newP     = OpenSSL::BN.new(p, 10)

    tracker_number_in_group = newAlpha.mod_exp(newP - 1 - newSK, newP).mod_mul(newBeta, newP).to_i


    trackers = CSV.parse(File.read('/public/files/public-tracker-numbers.csv'), headers: true)
    tn = trackers.select {|row| row["trackerNumberInGroup"].to_i == tracker_number_in_group.to_i}.first

    @plainTrackerNumber = tn["trackerNumber"]
    mixed_votes = CSV.parse(File.read('/public/files/public-mixed-voters.csv'), headers: true)
    plain_vote_row = mixed_votes.select {|row| row["trackerNumber"].to_i == @plainTrackerNumber.to_i}.first

    @plainVote = plain_vote_row["plainTextVote"]


    @hasedVote = Digest::SHA1.hexdigest @plainVote
  end 

end